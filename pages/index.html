<!DOCTYPE html>
<html>
<head>
  <title>Xenon</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="icon" href="../icons/favicon.png">
</head>
<body>
  <canvas id="render"></canvas>
  <script>
    // var movement = {speed: 1.0,friction: 1.0,grip: 1.0,stop: 1.0,slip: 0.0} //sharp
    // var movement = {speed: 1.0,friction: 0.05,grip: 1.0,stop: 1.0,slip: 0.0} //smooth
    var movement = {speed: 1.0,friction: 0.05,grip: 0.2,stop: 0.0,slip: 1.0,zoomSpeed: 0.001} //buttery
    // var movement = {speed: 2.0,friction: 0.05,grip: 0.0,stop: 1.0,slip: 1.0} //quick
    // var movement = {speed: 1.0,friction: 0.01,grip: 0.05,stop: 0.5,slip: 1.0} //slippery
    // var movement = {speed: 2.0,friction: 0.0,grip: 0.01,stop: 0.0,slip: 1.0} //wd40

    var render = {x: 0, y: 0, zoom: 1.0, canvas: document.getElementById('render'), width: window.innerWidth, height: window.innerHeight}

    render.ctx = render.canvas.getContext('2d')
    render.canvas.width = render.width;
    render.canvas.height = render.height;

    const rectSize = 50;

    // Function to draw a black square in the center
    function drawSquare(x, y) {
      render.ctx.clearRect(0, 0, render.width, render.height);
      render.ctx.fillStyle = 'black';
      render.ctx.fillRect(x - rectSize / 2, y - rectSize / 2, rectSize, rectSize);
    }

    // Initialize the square position at the center
    const squareX = render.width / 2;
    const squareY = render.height / 2;
    drawSquare(squareX, squareY);

    // Variables to track mouse positions and canvas transformation with velocity
    var isDragging = false;
    let startX, startY;
    let lastTime = 0;
    let velocityX = 0;
    let velocityY = 0;

    // Function to handle mouse down event
    document.body.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      velocityX *= 1-movement.stop;
      velocityY *= 1-movement.stop;
    });

    // Function to handle mouse up event
    document.body.addEventListener('mouseup', () => {
      isDragging = false;
    });

    // Function to handle mouse move event
    document.body.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const dx = mouseX - startX;
      const dy = mouseY - startY;

      startX = mouseX;
      startY = mouseY;

      let factor = movement.speed*(1-movement.slip)
      render.x += dx*factor;
      render.y += dy*factor;

      velocityX = dx;
      velocityY = dy;

      render.canvas.style.transform = `translate(${render.x}px, ${render.y}px) scale(${render.zoom})`;
    });

    // Function to handle mouse wheel event for zooming
    document.body.addEventListener('wheel', (e) => {
      const zoomFactor = 1 - e.deltaY * movement.zoomSpeed;

      const scaleChange = zoomFactor - 1;
      

      let rect = render.canvas.getBoundingClientRect()
      let currentX = ((e.clientX-rect.left)/render.zoom)-render.width/2
      let currentY = ((e.clientY-rect.top)/render.zoom)-render.height/2
      
      render.x-=((currentX*zoomFactor)-currentX)*render.zoom
      render.y-=((currentY*zoomFactor)-currentY)*render.zoom

      render.zoom *= zoomFactor;

      render.canvas.style.transform = `translate(${render.x}px, ${render.y}px) scale(${render.zoom})`;
    });


    // Function to update canvas position with velocity persistence
    render.update = () => {
      let factor =(isDragging?movement.slip:1)*movement.speed
      render.x += velocityX*factor;
      render.y += velocityY*factor;

      render.canvas.style.transform = `translate(${render.x}px, ${render.y}px) scale(${render.zoom})`;

      let decay = (isDragging?(1-movement.grip):(1-movement.friction))
      velocityX *= decay;
      velocityY *= decay;
      requestAnimationFrame(render.update);
    }

    // Initial call to the update function
    requestAnimationFrame(render.update);
  </script>
</body>
</html>
